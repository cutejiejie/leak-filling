/* 
高效的字符串前缀匹配
有一个英文单词库(数组)，里面有几十万个英文单词
输入一个字符串，快速判断是不是某一个单词的前缀
(说明思路，不用写代码)
 */

/* 
常规思路
第一,遍历单词库数组
第二, indexOf判断前缀
实际时间复杂度超过了O(n) 1因为要考虑indexOf的计算量
 */

/* 
优化
英文字母共26个,可以提前把单词库数组拆分为26个
既然第一层拆分为26个，第二层、第三层，还可以继续拆分
最后把单词库拆分为一棵树
 */
// 例如：
const arr = ["abs", "arab", "array", "arrow", "boot", "boss"];
// obj.a.r.r.a.y // 对象取key O(1)  O(m)

/* 
性能分析
如遍历数组，时间复杂度至少O(n)起步( n是数组长度)
而改为树，时间复杂度降低到O(m) ( m是单词的长度)
PS:哈希表(对象)通过key查询，时间复杂度是0(1) 
*/

// hash table 逻辑结构

// Object 物理结构
// Map
// C 结构体
// Java HashMap

/* 
划重点
考虑优化原始数据结构(需和面试官沟通确认)
有明确范围的数据(如26个英文字母)，考虑使用哈希表(对象)
以空间换时间，定义数据结构最重要
 */
